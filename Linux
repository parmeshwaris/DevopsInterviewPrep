20. How to list running processes
bash
ps aux       # Detailed list of all processes
top          # Interactive process viewer
htop         # Enhanced `top` (install with `yum install htop`)
pstree       # Processes in tree format
Use Case: Monitoring system resource usage.

21. Login to EC2 if PEM key is lost
Stop the EC2 instance (AWS Console → EC2 → Stop Instance).

Detach the root volume.

Attach it to another EC2 instance as a secondary volume.

Mount the volume and edit /home/ec2-user/.ssh/authorized_keys to add a new SSH key.

Reattach the volume to the original instance and restart.

Use Case: Recovering access to a locked EC2 instance.

22. Check memory in Linux
bash
free -h      # Human-readable memory usage (RAM + Swap)
top          # Live memory usage
htop         # Better visualization
vmstat       # Virtual memory stats
cat /proc/meminfo  # Detailed memory info
Use Case: Diagnosing high memory usage (free -h | grep "Mem").

23. Get server IP address
bash
hostname -I          # Internal IP
curl ifconfig.me      # Public IP (requires internet)
ip a                 # All network interfaces
ifconfig             # Legacy command (deprecated on newer systems)
Use Case: Configuring networking or firewall rules.

24. Check available storage
bash
df -h                 # Disk space (human-readable)
du -sh /path          # Directory size
lsblk                 # Block devices (disks/partitions)
Use Case: Checking disk usage before installing software.

25. Find files >10GB in size
bash
find / -type f -size +10G  # Search entire filesystem
find /var -type f -size +10G  # Search in /var
-type f → Only files (not directories).

-size +10G → Files larger than 10GB.

Use Case: Cleaning up disk space by identifying large log files or backups.

Bonus: Runlevel Commands (Deprecated in systemd)
Old SysV Init:

bash
runlevel          # Check current runlevel
init 3            # Switch to runlevel 3 (multi-user)
Modern systemd:

bash
systemctl get-default      # Get default target
systemctl set-default multi-user.target  # Set runlevel 3
Use Case: Switching between GUI (runlevel 5) and CLI (runlevel 3) modes.

Let me know if you'd like deeper explanations on any topic! 🚀

give all the above questions and answers in .md format
Here's the complete markdown (.md) formatted version of all the questions and answers:

markdown
# Linux Command Questions & Answers

## 11. Shell Script to Print All Alternative Lines
```bash
#!/bin/bash
awk 'NR % 2 == 1' "$@"
Explanation:

Prints odd-numbered lines (1, 3, 5,...) using awk

NR = current line number

$@ = accepts file input or stdin

Use Case:
Quickly analyze large files by viewing every other line:

bash
./script.sh large_log.log | head -20
14. Find Complete Linux Version Details
bash
uname -a                 # Kernel info
cat /etc/os-release      # OS details (best)
hostnamectl              # Systemd systems
lsb_release -a           # LSB info
Key Files:

/etc/centos-release (RHEL/CentOS)


15. PS -EF Command
bash
ps -ef | grep nginx  # Find specific processes
Back to Top

16. Kill -9 Processname
bash
kill -9 <PID>  # Force kill
kill -15 <PID> # Graceful kill
Back to Top

17. Special Variables
bash
echo $?   # Last exit status
echo $0   # Script name
echo $*   # All arguments
Back to Top

18. SSH Command
bash
ssh -i key.pem user@1.2.3.4 -p 22
Back to Top

19. Port Numbers of SSH/HTTP/HTTPS
Service	Port
SSH	22
HTTP	80
HTTPS	443
Back to Top

20. List Running Processes
bash
top        # Live view
htop       # Enhanced top
ps aux     # Detailed list
Back to Top

21. Login to EC2 if PEM Key Lost
Stop instance

Detach root volume

Attach to another instance

Modify authorized_keys

Reattach and restart

Back to Top

22. Check Memory in Linux
bash
free -h    # Human readable
vmstat     # Virtual memory
Back to Top

23. Get Server IP Address
bash
hostname -I    # Internal IP
curl ifconfig.me # Public IP
Back to Top

24. Check Server Storage
bash
df -h      # Disk space
du -sh *   # Directory sizes
Back to Top

25. Find Files >10GB
bash
find / -type f -size +10G  # System-wide
find /var -size +10G       # Specific directory

# Linux User Management: Essential Commands & Concepts

## 1. Create a New User
```bash
sudo useradd -m username           # Basic creation with home directory
sudo useradd -m -G developers,sudo username  # With secondary groups
sudo passwd username              # Set password
Use Case:
Onboarding new team member who needs developer access:

bash
sudo useradd -m -G devops,ssh johndoe
sudo passwd johndoe
2. Delete User with Home Directory
bash
sudo userdel -r username
Use Case:
Employee offboarding - completely remove all traces of a departed team member.

Warning:
-r also removes mail spool and other user-owned files outside home directory.

3. Change User Password
bash
sudo passwd username     # Root changing others' passwords
passwd                   # Users changing their own password
Use Case:
Monthly password rotation policy enforcement.

4. Modify Login Shell
bash
sudo usermod -s /bin/bash username   # Change to bash
sudo usermod -s /sbin/nologin username # Disable shell access
Use Case:
Converting a regular user to a service account by setting /sbin/nologin.

5. /etc/passwd vs /etc/shadow
File	Contents	Permissions
/etc/passwd	User info (UID, GID, shell)	World-readable
/etc/shadow	Encrypted passwords, expiry dates	Root-only
Example Entry:
/etc/passwd:
johndoe:x:1001:1001:John Doe:/home/johndoe:/bin/bash

/etc/shadow:
johndoe:$6$salt$hash:18647:0:99999:7:::

6. Create Group & Add User
bash
sudo groupadd developers      # Create group
sudo usermod -aG developers username  # Add user
groups username              # Verify
Use Case:
Setting up Docker access without sudo:

bash
sudo groupadd docker
sudo usermod -aG docker $USER
7. Set Password Expiry
bash
sudo chage -M 90 -W 7 username  # Expires in 90 days, warns 7 days prior
sudo chage -l username          # View settings
Use Case:
PCI-DSS compliance requiring 90-day password rotation.

8. Switch Between Users
bash
su - username       # Login shell (requires password)
sudo -i -u username # With sudo privileges
exit                # Return to original user
Use Case:
Troubleshooting as another user without logout:

bash
sudo -i -u postgres
psql
exit
9. /etc/login.defs Purpose
Controls default settings for:

Password aging (PASS_MAX_DAYS)

UID/GID ranges (UID_MIN, GID_MAX)

Home directory creation (CREATE_HOME)

Use Case:
Enforcing company-wide password policy:

ini
PASS_MAX_DAYS 90
PASS_WARN_AGE 7
10. Lock/Unlock Accounts
bash
sudo passwd -l username   # Lock
sudo passwd -u username   # Unlock
sudo usermod --expiredate 1 username # Temporary disable
Use Case:
Security incident response - immediately locking compromised accounts.

11. UID & GID Explained
UID: User ID (0=root, 1-999=system, 1000+=regular)

GID: Group ID (same numbering scheme)

Importance:

File ownership/permissions (ls -n shows numeric IDs)

Process privileges (Docker uses UID/GID mapping)

Service accounts should use UIDs <1000

Example:

bash
sudo useradd -r -u 120 -s /sbin/nologin myservice
Best Practices
Always use -m with useradd to create home directories

Prefer usermod -aG over usermod -G to avoid removing existing groups

Regularly audit /etc/passwd for unexpected UID 0 accounts

Use visudo instead of directly editing /etc/sudoers

Audit Command:

bash
awk -F: '($3 == 0) {print}' /etc/passwd  # Find all root-equivalent accounts
Would you like me to add specific troubleshooting scenarios or advanced ACL management examples?

# Linux File Permissions: Complete Guide

## 1. Basic Permission Symbols
| Symbol | Meaning          | File Effect            | Directory Effect       |
|--------|------------------|------------------------|------------------------|
| `r`    | Read             | View file content      | List directory contents|
| `w`    | Write            | Modify file content    | Create/delete files    |
| `x`    | Execute          | Run as program         | Enter (cd) directory   |
| `-`    | No permission    | N/A                    | N/A                    |

**Example**:  
`-rwxr-xr--` = Owner (rwx), Group (r-x), Others (r--)

---

## 2. Change File Ownership
```bash
chown user:group file.txt      # Change both owner and group
chown alice file.txt          # Change owner only
chown :developers file.txt    # Change group only
sudo chown -R www-data:www-data /var/www  # Recursive for directories
Use Case:
After extracting a tar archive as root:

bash
chown -R deploy:deploy /opt/app
3. chmod 755 vs 777
Permission	Owner	Group	Others	Typical Use
755	rwx	r-x	r-x	Executables, web directories
777	rwx	rwx	rwx	Dangerous - world-writable
Security Alert:
Never use 777 on production systems. Instead:

bash
chmod 755 /shared_dir      # Execute needed for directory traversal
chmod 644 /shared_dir/*.log  # Files don't need execute
4. Recursive Permission Changes
bash
chmod -R 750 /opt/app      # All files and subdirectories
find /opt/app -type f -exec chmod 640 {} \;  # Files only
find /opt/app -type d -exec chmod 750 {} \;  # Directories only
Use Case:
Securing a web application:

bash
chown -R www-data:www-data /var/www
find /var/www -type d -exec chmod 750 {} \;
find /var/www -type f -exec chmod 640 {} \;
5. Special Permission Bits
Bit	Symbol	Effect (Files)	Effect (Directories)
SUID	s	Runs as owner	-
SGID	s	Runs as group	New files inherit group
Sticky	t	-	Only owner can delete files
Examples:

bash
chmod u+s /usr/bin/passwd   # SUID (allows password changes)
chmod g+s /shared_dir      # SGID (team collaboration)
chmod +t /tmp              # Sticky bit (secure temp dir)
Security Use Case:

bash
chmod 1777 /upload         # Users can only delete their own uploads
6. View Permissions with ls
bash
ls -l file.txt       # Basic view
ls -ld /opt          # View directory itself (not contents)
ls -lah              # Human-readable + hidden files
stat file.txt        # Detailed info including ACLs
Sample Output:
drwxr-sr-t 2 alice developers 4.0K Jun 10 15:30 shared/

d = Directory

rwsr-sr-t = Permissions + SUID/SGID/Sticky

7. Hard Links vs Soft Links
Feature	Hard Link	Soft (Symbolic) Link
Inode	Same as original	New inode
Cross-filesystem	No	Yes
If original deleted	Still accessible	Broken link
Creation	ln original link	ln -s original link
Use Cases:

Hard Link: Maintaining multiple names for critical system files

Soft Link:

bash
ln -s /mnt/volume1/data /opt/app/data  # Portable path reference
8. umask for Default Permissions
bash
umask 022       # New files: 644 (rw-r--r--), dirs: 755 (rwxr-xr-x)
umask 027       # More restrictive (files: 640, dirs: 750)
Permanent Setting:
Add to ~/.bashrc or /etc/profile:

bash
umask 007  # Group read/write, others no access
Use Case:
Development team environment where group members need full access:

bash
umask 002  # Files: 664, Dirs: 775
9. ACL (Access Control Lists)
Basic Commands:

bash
setfacl -m u:alice:rwx file.txt  # Add user
setfacl -m g:devops:rx dir/       # Add group
getfacl file.txt                  # View ACLs
setfacl -x g:temp file.txt        # Remove entry
Advanced Use Cases:

Case 1: Web Server + Developers
bash
chown www-data:developers /var/www
setfacl -R -m u:www-data:rwx /var/www
setfacl -R -m g:developers:rwx /var/www
setfacl -R -d -m g:developers:rwx /var/www  # Default for new files
Case 2: Audit Log Access
bash
setfacl -m u:auditor:r-- /var/log/sensitive.log
Case 3: Temporary Contractor Access
bash
setfacl -m u:contractor:r-x /opt/app
# Later remove:
setfacl -x u:contractor /opt/app
ACL vs Traditional Permissions:

Standard permissions: Limited to one owner/group/others

ACLs: Multiple users/groups with different permissions

Permission Troubleshooting Cheat Sheet
bash
# Find world-writable files:
find / -xdev -type f -perm -o+w

# Find files with SUID/SGID:
find / -xdev \( -perm -4000 -o -perm -2000 \) -type f

# Reset broken permissions:
find /opt/app -type d -exec chmod 750 {} \;
find /opt/app -type f -exec chmod 640 {} \;
Best Practices
Principle of Least Privilege: Start with restrictive permissions (750/640)

Use Groups: Better than 777 (create a group for collaborators)

ACLs > SUID: Prefer ACLs over SUID binaries when possible

Sticky Bit: Essential for shared directories like /tmp

Audit Regularly: Check for anomalous permissions with find commands

How to Check Running Processes in Linux
Linux provides multiple commands to monitor running processes, each with different levels of detail and use cases. Below are the most common methods:

1. ps (Process Status)
Displays a snapshot of currently running processes.

Basic Usage
bash
ps aux
a: Show processes for all users

u: Display user-oriented format (CPU, memory)

x: Include processes not attached to a terminal

Common Filters
bash
ps aux | grep nginx      # Find specific process
ps -ef | grep python     # Show full-format listing
ps -p <PID> -o pid,cmd  # Check a specific PID
Output Columns
text
USER    PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      1  0.0  0.5 169316 10896 ?        Ss   Jun10   0:12 /sbin/init
PID: Process ID

%CPU: CPU usage

%MEM: Memory usage

COMMAND: Process name

2. top (Real-Time Process Monitor)
Interactive dynamic view of running processes.

Basic Usage
bash
top
Key Features
Sort by CPU (P), Memory (M), or Time (T)

Kill a process (k + PID)

Change update interval (d + seconds)

Example Output
text
top - 14:30:05 up 10 days,  3:15,  2 users,  load avg: 0.50, 0.75, 0.80
Tasks: 150 total,   2 running, 148 sleeping,   0 stopped,   0 zombie
%Cpu(s):  5.3 us,  1.2 sy,  0.0 ni, 93.5 id,  0.0 wa,  0.0 hi,  0.0 si
KiB Mem :  8000000 total,  2000000 free,  3000000 used,  3000000 buff/cache
PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
1234 root      20   0  500000  80000  10000 R  25.0  1.0   5:30.25 python3
3. htop (Enhanced top)
A more user-friendly, color-coded alternative.

Installation
bash
sudo apt install htop    # Debian/Ubuntu
sudo yum install htop    # RHEL/CentOS
Usage
bash
htop
Advantages Over top
Tree view (F5)

Mouse support

Easier process killing (F9)

Customizable columns

4. pgrep & pkill (Find/Kill by Name)
Find a Process
bash
pgrep -l nginx      # List PIDs and names
pgrep -u root       # Find processes by user
Kill a Process
bash
pkill nginx         # Kill by name
pkill -U username   # Kill all processes of a user
5. systemctl (Systemd Services)
Check and manage services (modern Linux distros).

List Running Services
bash
systemctl list-units --type=service --state=running
Check a Specific Service
bash
systemctl status nginx
6. lsof (List Open Files)
Find which process is using a file/port.

Common Uses
bash
lsof -i :80         # Find processes using port 80
lsof /var/log/syslog # See who’s accessing a file
lsof -u apache      # List files opened by a user
7. pstree (Hierarchical View)
Shows parent-child process relationships.

bash
pstree -p   # Show PIDs
pstree -u   # Show users
Example Output:

text
systemd(1)─┬─nginx(1234)─┬─nginx(1235)
           ├─sshd(5678)───bash(9012)
           └─docker(3456)
8. /proc Filesystem (Low-Level Info)
Manual inspection of running processes.

bash
cat /proc/<PID>/status  # Detailed process info
ls /proc/               # List all running PIDs
Summary Table: When to Use Which Command
Command	Best For	Example
ps aux	Quick snapshot	ps aux | grep java
top/htop	Real-time monitoring	htop (interactive)
pgrep	Finding PIDs by name	pgrep -l python
pkill	Killing by name	pkill -9 chrome
systemctl	Managing services	systemctl status sshd
lsof	Checking open files/ports	lsof -i :22
pstree	Process hierarchy	pstree -p
Common Use Cases
Find High CPU/Memory Usage

bash
top (then press P or M)
ps aux --sort=-%cpu | head
Kill a Frozen Process

bash
pkill -9 firefox   # Force kill
kill -9 1234       # By PID
Check if a Service is Running

bash
systemctl is-active nginx
ps aux | grep nginx
Find Which Process is Using a Port

bash
lsof -i :80
ss -tulnp | grep 80
Final Tips
Use htop for an interactive, user-friendly experience.

Combine ps, grep, and awk for advanced filtering:

bash
ps aux | awk '$3 > 50 {print $0}'  # Show processes using >50% CPU
For containers/Docker, use:

bash
docker ps
docker stats
Let me know if you need deeper dives into any specific tool! 🚀

What’s the diƯerence between ps, top, and htop?
Here’s a clear breakdown of the differences between ps, top, and htop:

1. ps (Process Status)
Type: Static snapshot

Output: One-time list of processes

Key Features:

Lightweight, no interactive interface

Flexible filtering (e.g., by user, PID, or command)

Often combined with grep/awk for analysis

Example:

bash
ps aux | grep nginx  # Find Nginx processes
Use Case:
Quick checks or scripting (e.g., if ps aux | grep -q "nginx"; then...).

2. top (Table of Processes)
Type: Real-time, interactive

Output: Continuously updating process list

Key Features:

Built into all Linux systems (no installation needed)

Basic sorting (CPU/Memory/Time)

Can kill processes (k) or renice (r)

Example:

bash
top -o %CPU  # Sort by CPU usage
Use Case:
Monitoring system health during performance issues.

3. htop (Enhanced top)
Type: Real-time, interactive (modern)

Output: Color-coded, visual layout

Key Features:

Tree view (parent/child processes)

Mouse support

Easy killing (F9), filtering (F4)

Customizable columns

Example:

bash
htop --sort-key=PERCENT_CPU  # Launch sorted by CPU
Use Case:
Debugging complex process hierarchies or user-friendly monitoring.

Comparison Table
Feature	ps	top	htop
Output Type	Static	Real-time	Real-time
Interactivity	No	Basic	Advanced
Sorting	Via flags	Interactive	Interactive
Process Tree	No	No	Yes
Mouse Support	No	No	Yes
Kill Processes	Via kill	Yes (k)	Yes (F9)
Installation	Preinstalled	Preinstalled	apt install htop
When to Use Which
Need a quick list? → ps aux

Basic real-time monitoring? → top

Debugging complex processes? → htop

Scripting/automation? → ps (e.g., if pgrep -x "nginx" >/dev/null)

Pro Tip:

Use ps for precise queries:

bash
ps -eo pid,user,%cpu,%mem,cmd --sort=-%cpu | head  # Top CPU hogs
Use htop’s tree view (F5) to identify spawned child processes.

How do you kill a process by name or PID?
How to Kill a Process in Linux (by Name or PID)
You can terminate processes using either their Process ID (PID) or name. Below are the most common methods with examples:

1. Kill by PID
Find the PID First
bash
ps aux | grep <process_name>  # Example: ps aux | grep nginx
Output Example:

text
root      1234  0.0  0.5  50000  8000 ?        S    Jun10   0:10 nginx: master process
www-data  5678  0.0  0.3  30000  5000 ?        S    Jun10   0:05 nginx: worker process
1234 = Master Nginx PID

5678 = Worker Nginx PID

Kill the Process
bash
kill <PID>          # Graceful termination (SIGTERM, allows cleanup)
kill -9 <PID>       # Force kill (SIGKILL, immediate, no cleanup)
Example:

bash
kill 1234          # Ask Nginx to shut down gracefully
kill -9 5678       # Force-kill if unresponsive
2. Kill by Name
Using pkill (Kill by Process Name)
bash
pkill <process_name>         # Graceful (SIGTERM)
pkill -9 <process_name>      # Force kill (SIGKILL)
pkill -f "<full_command>"   # Match full command line
Examples:

bash
pkill nginx           # Graceful shutdown
pkill -9 python3      # Force-kill all Python3 processes
pkill -f "java -jar app.jar"  # Kill a specific Java app
Using killall (Kill All Instances)
bash
killall <process_name>        # Graceful (SIGTERM)
killall -9 <process_name>     # Force kill (SIGKILL)
killall -u <username>         # Kill all processes of a user
Examples:

bash
killall chrome         # Close all Chrome processes gracefully
killall -9 node        # Force-kill all Node.js processes
killall -u bob         # Terminate all processes owned by user "bob"
3. Kill by Port (If PID/Name Unknown)
Find and kill a process using a specific port (e.g., 8080):

bash
sudo lsof -i :8080        # Find PID using port 8080
sudo kill -9 $(sudo lsof -t -i :8080)  # Force-kill it
4. Kill a Background Job (Shell Jobs)
If the process was started in your current shell session:

bash
jobs               # List background jobs
kill %1            # Kill job ID 1 (graceful)
kill -9 %2         # Force-kill job ID 2
Key Signals
Signal	Number	Effect
SIGTERM	15	Graceful shutdown (default)
SIGKILL	9	Force kill (no cleanup)
SIGHUP	1	Restart (e.g., kill -1 on Nginx reloads config)
Best Practices
Try SIGTERM (default kill) first to allow cleanup.

Use SIGKILL (-9) only if the process is frozen.

Verify the process is gone:

bash
ps aux | grep <process_name>  # Check if still running
For system services, prefer:

bash
sudo systemctl stop nginx     # Proper service stop
Common Use Cases
Graceful shutdown (e.g., databases, web servers):

bash
kill <PID>   # SIGTERM
Force-kill a frozen app (e.g., Chrome, Java):

bash
pkill -9 chrome
Stop a process on a specific port:

bash
sudo kill -9 $(sudo lsof -t -i :3000)
Summary
kill <PID> → Graceful termination

kill -9 <PID> → Force kill

pkill <name> → Kill by process name

killall <name> → Kill all instances of a process

lsof -i :<port> → Find and kill by port

Let me know if you need help with a specific scenario! 🚀

How do you make a service start on boot?
How to Make a Service Start on Boot in Linux
There are two primary methods to auto-start services at boot, depending on your Linux system's init system:

1. systemd (Modern Linux - Ubuntu 16.04+, RHEL 7+, CentOS 7+)
Most modern distributions use systemd.

Enable a Service at Boot
bash
sudo systemctl enable <service_name>  # Example: sudo systemctl enable nginx
Verify
bash
sudo systemctl is-enabled <service_name>  # Should return "enabled"
Common Commands
Command	Description
sudo systemctl start <service>	Start immediately
sudo systemctl stop <service>	Stop immediately
sudo systemctl restart <service>	Restart
sudo systemctl status <service>	Check status
Example (Enable Nginx at Boot):

bash
sudo systemctl enable nginx   # Auto-start at boot
sudo systemctl start nginx    # Start now
2. SysV Init (Older Linux - Ubuntu 14.04, RHEL 6, CentOS 6)
Older systems use chkconfig or update-rc.d.

Enable a Service at Boot
On RHEL/CentOS 6 (chkconfig)
bash
sudo chkconfig <service_name> on  # Example: sudo chkconfig httpd on
On Debian/Ubuntu (update-rc.d)
bash
sudo update-rc.d <service_name> defaults  # Example: sudo update-rc.d apache2 defaults
Verify
bash
chkconfig --list <service_name>  # (RHEL/CentOS)
ls /etc/rc*.d/ | grep <service>  # (Debian/Ubuntu)
Example (Enable Apache at Boot):

bash
sudo chkconfig httpd on    # RHEL/CentOS 6
sudo service httpd start   # Start now
3. Manual Setup (For Custom Scripts)
If your service isn’t managed by systemd or SysV, you can add it to:

rc.local (Older systems)

Cron @reboot

Systemd custom service file

Method 1: rc.local (Deprecated but still works)
Edit /etc/rc.local:

bash
sudo nano /etc/rc.local
Add your command before exit 0:

bash
/path/to/your/script.sh &
Make it executable:

bash
sudo chmod +x /etc/rc.local
Method 2: Cron @reboot
bash
crontab -e
Add:

bash
@reboot /path/to/script.sh
Method 3: Create a Custom systemd Service
Create a service file:

bash
sudo nano /etc/systemd/system/myservice.service
Add:

ini
[Unit]
Description=My Custom Service
After=network.target

[Service]
ExecStart=/usr/bin/python3 /opt/myscript.py
Restart=always
User=root

[Install]
WantedBy=multi-user.target
Enable it:

bash
sudo systemctl enable myservice
sudo systemctl start myservice
Which Method Should You Use?
System	Command
Ubuntu 18.04+, RHEL 7+	sudo systemctl enable <service>
CentOS 6, RHEL 6	sudo chkconfig <service> on
Debian (older)	sudo update-rc.d <service> defaults
Custom Scripts	systemd service file or @reboot cron
Troubleshooting
Check logs:

bash
journalctl -u <service_name>  # systemd
tail /var/log/syslog          # SysV
Test manually first:

bash
sudo systemctl start <service>  # systemd
sudo service <service> start    # SysV
Final Notes
✅ For standard services (Nginx, MySQL, Docker), use systemctl enable.
✅ For custom scripts, use systemd service files or @reboot in cron.
🚫 Avoid rc.local on modern systems (deprecated).

Let me know if you need help with a specific service! 🚀

How do you run a process in the background
How to Run a Process in the Background (Linux/Unix)
There are multiple ways to run processes in the background, depending on your needs:

1. Using & (Simple Background Execution)
Append & to a command to run it in the background immediately.

bash
ping google.com > ping.log &
Process continues running even if you close the terminal.

Output is lost unless redirected (> file.log).

Check running background jobs:

bash
jobs -l  # Lists background jobs with their PIDs
Bring back to foreground:

bash
fg %1  # Resume job ID 1
2. Using nohup (Persists After Logout)
Keeps the process running even after closing the terminal or SSH session.

bash
nohup ping google.com > ping.log &
Output is saved to nohup.out (unless redirected).

Ignores SIGHUP (hangup signal).

Kill the process later:

bash
pkill -f "ping google.com"
3. Using screen or tmux (Terminal Multiplexers)
Best for long-running tasks (e.g., servers, scripts).

With screen
bash
screen -S mysession  # Start a new named session
ping google.com      # Run your command
Ctrl+A, D            # Detach (process keeps running)
Reattach later:

bash
screen -r mysession  # Resume session
With `tmux (Modern alternative)**
bash
tmux new -s mysession  # Start new session
ping google.com        # Run command
Ctrl+B, D             # Detach
Reattach:

bash
tmux attach -t mysession
4. Using disown (Detach from Shell)
Run a process in the background and remove it from the shell’s job list.

bash
ping google.com > ping.log &  # Run in background
disown -h %1                 # Detach from shell
Process survives terminal closure.

No output logging unless redirected.

5. Using systemd (Permanent Background Service)
Best for daemons (e.g., web servers, databases).

Create a service file
bash
sudo nano /etc/systemd/system/myservice.service
Add this (example for a Python script):

ini
[Unit]
Description=My Background Service

[Service]
ExecStart=/usr/bin/python3 /home/user/myscript.py
Restart=always
User=root

[Install]
WantedBy=multi-user.target
Start & enable at boot
bash
sudo systemctl start myservice
sudo systemctl enable myservice  # Auto-start on boot
Check status:

bash
sudo systemctl status myservice
6. Using cron (Scheduled Background Tasks)
Run a script at reboot (@reboot in crontab).

bash
crontab -e
Add:

bash
@reboot /path/to/script.sh > /var/log/script.log 2>&1 &
Comparison Table
Method	Survives Logout?	Output Logging	Best For
&	❌ No	❌ (Unless redirected)	Quick tasks
nohup	✅ Yes	✅ (nohup.out)	Long scripts
screen/tmux	✅ Yes	✅ (Visible when reattached)	Interactive tasks
disown	✅ Yes	❌ (Unless redirected)	Detaching existing jobs
systemd	✅ Yes	✅ (journalctl)	Daemons/services
cron @reboot	✅ Yes	✅ (If redirected)	Startup scripts
Best Practices
For temporary tasks: Use & or nohup.

For interactive tasks: Use screen or tmux.

For permanent services: Use systemd.

Always redirect output (> file.log) if logging is needed.

Example (Run a Python script persistently):

bash
nohup python3 app.py > app.log 2>&1 &
2>&1 redirects errors to the same log file.

Killing Background Processes
bash
pkill -f "app.py"          # Kill by name
kill $(pgrep -f "app.py")  # Kill by PID
Let me know if you need help with a specific use case! 🚀

How do you start, stop, restart, and check status of a service?
How to Start, Stop, Restart, and Check the Status of a Service in Linux
Linux provides different methods to manage services, depending on whether your system uses systemd (modern) or SysV init (older). Below are the most common commands:

1. Using systemd (Ubuntu 16.04+, RHEL/CentOS 7+, Debian 8+)
Most modern Linux distributions use systemd.

Command	Description	Example
Start a Service	sudo systemctl start <service>	sudo systemctl start nginx
Stop a Service	sudo systemctl stop <service>	sudo systemctl stop apache2
Restart a Service	sudo systemctl restart <service>	sudo systemctl restart mysql
Reload (without full restart)	sudo systemctl reload <service>	sudo systemctl reload nginx
Check Status	sudo systemctl status <service>	sudo systemctl status sshd
Enable at Boot	sudo systemctl enable <service>	sudo systemctl enable docker
Disable at Boot	sudo systemctl disable <service>	sudo systemctl disable postgresql
List All Services	systemctl list-units --type=service	systemctl list-units --type=service | grep running
Example: Managing Nginx

bash
sudo systemctl start nginx      # Start
sudo systemctl stop nginx       # Stop
sudo systemctl restart nginx    # Restart
sudo systemctl reload nginx     # Reload config (no downtime)
sudo systemctl status nginx     # Check status
sudo systemctl enable nginx     # Start at boot
sudo systemctl disable nginx    # Disable auto-start
2. Using SysV Init (Older Systems: RHEL/CentOS 6, Ubuntu 14.04)
Older Linux systems use service or /etc/init.d/ scripts.

Command	Description	Example
Start a Service	sudo service <service> start	sudo service httpd start
Stop a Service	sudo service <service> stop	sudo service mysqld stop
Restart a Service	sudo service <service> restart	sudo service ssh restart
Check Status	sudo service <service> status	sudo service apache2 status
Enable at Boot	sudo chkconfig <service> on	sudo chkconfig httpd on
Disable at Boot	sudo chkconfig <service> off	sudo chkconfig mysqld off
Example: Managing Apache (httpd)

bash
sudo service httpd start       # Start
sudo service httpd stop        # Stop
sudo service httpd restart     # Restart
sudo service httpd status      # Check status
sudo chkconfig httpd on        # Enable at boot (RHEL/CentOS 6)
sudo update-rc.d apache2 defaults  # Enable at boot (Debian/Ubuntu)
3. Using systemctl vs service (Comparison)
Action	systemd (systemctl)	SysV Init (service)
Start	sudo systemctl start nginx	sudo service nginx start
Stop	sudo systemctl stop nginx	sudo service nginx stop
Restart	sudo systemctl restart nginx	sudo service nginx restart
Status	sudo systemctl status nginx	sudo service nginx status
Enable at Boot	sudo systemctl enable nginx	sudo chkconfig nginx on (RHEL 6)
Disable at Boot	sudo systemctl disable nginx	sudo chkconfig nginx off (RHEL 6)
4. Checking Service Logs
If a service fails, check logs for errors:

For systemd
bash
journalctl -u nginx -xe   # View logs for Nginx
journalctl --since "1 hour ago"  # Recent logs
For SysV Init
bash
tail -f /var/log/nginx/error.log  # Nginx error logs
cat /var/log/syslog | grep apache # Filter logs for Apache
5. Troubleshooting
Service won’t start?

bash
sudo systemctl status nginx -l  # Show full error logs
sudo journalctl -xe            # Check system-wide errors
Port conflict?

bash
sudo ss -tulnp | grep 80  # Check if port 80 is in use
Missing service?

bash
sudo systemctl list-unit-files | grep nginx  # Check if installed
Summary Cheat Sheet
Task	systemd Command	SysV Init Command
Start	sudo systemctl start <service>	sudo service <service> start
Stop	sudo systemctl stop <service>	sudo service <service> stop
Restart	sudo systemctl restart <service>	sudo service <service> restart
Status	sudo systemctl status <service>	sudo service <service> status
Enable at Boot	sudo systemctl enable <service>	sudo chkconfig <service> on
Disable at Boot	sudo systemctl disable <service>	sudo chkconfig <service> off
Final Notes
✅ Use systemctl on modern Linux (Ubuntu 20.04+, RHEL 8+, Debian 10+).
✅ Use service on older systems (RHEL 6, Ubuntu 14.04).
🔧 Always check logs (journalctl or /var/log/) if a service fails.

Let me know if you need help with a specific service! 🚀

How do you make a process immune to hangups?
How to Make a Process Immune to Hangups (SIGHUP) in Linux
When a terminal session ends (e.g., closing SSH), processes receive a SIGHUP (Hangup signal) by default, which terminates them. Here’s how to make a process persist:

1. Using nohup (Simplest Method)
Runs a command immune to SIGHUP and detaches it from the terminal.

bash
nohup your_command &
Output is saved to nohup.out (unless redirected).

Ignores SIGHUP, but still tied to the shell (use disown for full detachment).

Example:

bash
nohup python3 server.py > server.log 2>&1 &
> server.log redirects output to a file.

2>&1 sends errors to the same log.

2. Using disown (Detach from Shell)
Removes a running job from the shell’s job table, making it survive terminal closure.

bash
your_command &  # Start in background
disown -h %1   # Remove job ID 1 from shell tracking
Example:

bash
python3 worker.py &
disown -h %1
3. Using screen or tmux (Terminal Multiplexers)
Creates a persistent session that stays alive even after logout.

With screen
bash
screen -S mysession   # Start named session
your_command          # Run process
Ctrl+A, D             # Detach (process keeps running)
Reattach later:

bash
screen -r mysession
With tmux (Modern Alternative)
bash
tmux new -s mysession  # Start session
your_command           # Run process
Ctrl+B, D              # Detach
Reattach:

bash
tmux attach -t mysession
4. Using setsid (Run in a New Session)
Starts the process in a new session (no controlling terminal).

bash
setsid your_command
Example:

bash
setsid python3 daemon.py > daemon.log 2>&1
5. Using systemd (For Permanent Services)
Best for long-running daemons (e.g., servers, databases).

Create a service file (/etc/systemd/system/mydaemon.service):
ini
[Unit]
Description=My Daemon

[Service]
ExecStart=/usr/bin/python3 /path/to/script.py
Restart=always
User=root

[Install]
WantedBy=multi-user.target
Start and enable:
bash
sudo systemctl start mydaemon
sudo systemctl enable mydaemon  # Start at boot
6. Using dtach or abduco (Lightweight Detach)
Alternatives to screen/tmux for low-resource environments.

bash
dtach -n /tmp/mysession your_command
Reattach with:

bash
dtach -a /tmp/mysession
Comparison of Methods

How to Verify Immunity
Start the process (e.g., nohup sleep 1000 &).

Check PID:

bash
ps aux | grep sleep
Close the terminal and reopen.

Confirm it’s still running:

bash
ps aux | grep sleep
Killing a Persistent Process
bash
pkill -f "sleep 1000"   # Kill by name
kill -9 <PID>           # Force kill
Key Takeaways
For quick tasks: nohup or disown.

For interactive work: screen/tmux.

For daemons: systemd.

Always redirect output (> file.log 2>&1) if logging is needed.

Let me know if you need help with a specific use case! 🚀

What is the diƯerence between systemctl disable and stop
Difference Between systemctl disable and systemctl stop
Command	Effect	When to Use	Persistence After Reboot
systemctl stop <service>	Immediately stops a running service.	- Temporarily halt a service (e.g., for maintenance).
- Debugging without permanent changes.	❌ Service will restart on reboot if enabled.
systemctl disable <service>	Removes the service from auto-start at boot.
(Does not stop it if currently running.)	- Permanently prevent a service from starting on boot.
- Decommissioning unused services.	✅ Service won’t restart on reboot, but may still run now.
Key Scenarios
Temporarily Stop a Service

bash
sudo systemctl stop nginx  # Nginx stops now but will restart on reboot if enabled.
Permanently Disable Auto-Start

bash
sudo systemctl disable nginx  # Nginx won’t start on boot, but keeps running now.
sudo systemctl stop nginx     # Stop it immediately (optional).
Stop + Disable Completely

bash
sudo systemctl stop nginx     # Stop now.
sudo systemctl disable nginx  # Prevent future auto-start.
Common Use Cases
Disable Unnecessary Services (e.g., bluetooth, postfix):

bash
sudo systemctl disable bluetooth  # Won’t start at boot, but runs until next reboot.
Temporary Maintenance (e.g., apache2):

bash
sudo systemctl stop apache2  # Stops Apache but leaves auto-start intact.
Permanent Removal (e.g., old mysql):

bash
sudo systemctl stop mysql
sudo systemctl disable mysql  # Ensures it never starts again.
How to Check Status
bash
sudo systemctl is-enabled nginx  # Check if enabled at boot.
sudo systemctl is-active nginx   # Check if currently running.
Summary
stop → Short-term action (does not affect boot behavior).

disable → Long-term action (prevents auto-start but doesn’t stop the service now).

For full removal: Use both (stop + disable).

🚀 Pro Tip: Use systemctl mask <service> to completely block a service (even manual starts will fail).

bash
sudo systemctl mask nginx  # Hard disable (revert with `unmask`).
How do you make a service start on boot?
How to Make a Service Start on Boot in Linux
To ensure a service starts automatically at boot, use the appropriate command based on your Linux system's init system. Most modern distributions use systemd, while older systems may use SysV init.

1. For systemd (Ubuntu 16.04+, RHEL/CentOS 7+, Debian 8+)
Most modern Linux systems use systemd.

Enable a Service at Boot
bash
sudo systemctl enable <service_name>
Example (Enable Nginx to start at boot):

bash
sudo systemctl enable nginx
Verify It’s Enabled
bash
sudo systemctl is-enabled nginx  # Should return "enabled"
Start the Service Immediately (Optional)
bash
sudo systemctl start nginx  # Starts now (without waiting for reboot)
2. For SysV Init (Older Systems: RHEL/CentOS 6, Ubuntu 14.04)
Older Linux systems use chkconfig (RHEL/CentOS) or update-rc.d (Debian/Ubuntu).

On RHEL/CentOS 6 (Using chkconfig)
bash
sudo chkconfig <service_name> on
Example (Enable Apache at boot):

bash
sudo chkconfig httpd on
On Debian/Ubuntu (Using update-rc.d)
bash
sudo update-rc.d <service_name> defaults
Example (Enable MySQL at boot):

bash
sudo update-rc.d mysql defaults
3. For Custom Scripts (Alternative Methods)
If your service isn’t managed by systemd or SysV, you can use:

Method 1: rc.local (Simple but outdated)
Edit /etc/rc.local:

bash
sudo nano /etc/rc.local
Add your command before exit 0:

bash
/path/to/your/script.sh &
Make it executable:

bash
sudo chmod +x /etc/rc.local
Method 2: Cron @reboot (User-level)
bash
crontab -e
Add:

bash
@reboot /path/to/script.sh
Method 3: Create a Custom systemd Service (Recommended)
Create a service file:

bash
sudo nano /etc/systemd/system/myservice.service
Add this template:

ini
[Unit]
Description=My Custom Service
After=network.target

[Service]
ExecStart=/usr/bin/python3 /path/to/script.py
Restart=always
User=root

[Install]
WantedBy=multi-user.target
Enable it:

bash
sudo systemctl enable myservice
sudo systemctl start myservice
How to Check if a Service is Set to Start on Boot
For systemd
bash
sudo systemctl is-enabled <service_name>
For SysV Init
bash
chkconfig --list <service_name>  # RHEL/CentOS
ls /etc/rc*.d/ | grep <service>  # Debian/Ubuntu
Troubleshooting
Service fails to start? Check logs:

bash
journalctl -u nginx -xe  # For systemd
tail /var/log/syslog     # For SysV
Test before rebooting:

bash
sudo systemctl start <service>  # systemd
sudo service <service> start   # SysV
Summary Table
System	Command	Example
Modern (systemd)	sudo systemctl enable nginx	Auto-starts Nginx at boot
Old RHEL (chkconfig)	sudo chkconfig httpd on	Enables Apache
Old Debian (update-rc.d)	sudo update-rc.d mysql defaults	Enables MySQL
Custom Scripts	@reboot in crontab or systemd service file	Best for user scripts


How do you find why a service failed using journal logs?
How to Find Why a Service Failed Using Journal Logs (systemd)
When a systemd service fails, the journalctl command is the best tool to diagnose issues. Here’s how to troubleshoot effectively:

1. Basic Service Logs
Check the logs for a specific service (e.g., nginx, mysql):

bash
sudo journalctl -u <service_name>
Example (Check Nginx logs):

bash
sudo journalctl -u nginx
Key Flags for Filtering Logs
Flag	Description
-u	Filter by service name
-e	Jump to the end of logs
-f	Follow (tail) logs in real-time
-n 50	Show last 50 lines
-b	Only logs since last boot
--since "1 hour ago"	Time-based filtering
Example (Show last 50 Nginx logs):

bash
sudo journalctl -u nginx -n 50
2. Find Critical Errors
Check Recent Errors
bash
sudo journalctl -u nginx -p 3 -xb
-p 3 = Show errors (3 = error level, 4 = warnings).

-x = Add explanations for errors.

-b = Only current boot.

Search for "Failed" Messages
bash
sudo journalctl -u nginx | grep -i "fail\|error\|exception"
3. Check Full Boot-Time Logs
If the service fails at startup:

bash
sudo journalctl -b | grep <service_name>
Example (Find MySQL startup issues):

bash
sudo journalctl -b | grep mysql
4. Check Timestamp of Failure
bash
sudo journalctl -u nginx --since "2024-01-01 00:00:00" --until "2024-01-02 12:00:00"
(Replace dates with your failure timeframe.)

5. Export Logs for Analysis
Save logs to a file:

bash
sudo journalctl -u nginx > nginx_logs.txt
6. Common Causes of Service Failures
Symptom	Likely Cause	Fix
"Failed to start"	Missing dependencies, bad config	sudo systemctl status nginx → Check config
"Permission denied"	Incorrect file ownership	chown/chmod fixes
"Address already in use"	Port conflict	sudo ss -tulnp | grep 80
"No such file or directory"	Missing executable	Reinstall the service
"Timeout"	Slow dependencies	Increase TimeoutStartSec in service file
7. Advanced Debugging
Check Full Service Status
bash
sudo systemctl status nginx -l
-l = Show full error messages.

Reload systemd and Restart Service
bash
sudo systemctl daemon-reload
sudo systemctl restart nginx
8. Example Workflow
Step 1: Check service status
bash
sudo systemctl status nginx
Step 2: View logs
bash
sudo journalctl -u nginx -xe
Step 3: Fix the issue (e.g., config error)
bash
sudo nano /etc/nginx/nginx.conf  # Fix config
sudo systemctl restart nginx
Summary
Command	Purpose
journalctl -u nginx	Basic logs for Nginx
journalctl -u nginx -p 3 -xb	Show only errors
journalctl -u nginx --since "1 hour ago"	Time-based filtering
systemctl status nginx -l	Detailed service status
sudo systemctl restart nginx	Restart after fixing
Final Tips
✅ Always check logs after systemctl start fails.
✅ Use -x for explanations of errors.
✅ If logs are too long, filter with grep.



Linux Networking: Essential Commands & Concepts
1. How to Check Your IP Address
Commands
bash
ip a                        # Modern (recommended)
ifconfig                    # Legacy (deprecated in many distros)
hostname -I                 # Quick internal IP
curl ifconfig.me            # Public IP (requires internet)
Use Cases
Troubleshooting: Verify if an interface has an IP.

Scripting: Use hostname -I in automation.

Cloud Servers: curl ifconfig.me to confirm public IP.

Comparison
Command	Pros	Cons
ip a	Detailed, modern	Verbose output
ifconfig	Familiar syntax	Not installed by default
hostname -I	Fast, script-friendly	Only shows primary IP
2. How to View Routing Table Information
Commands
bash
ip route show               # Modern (recommended)
route -n                   # Legacy
netstat -rn                # Alternative
Use Cases
Debugging: Check if traffic routes correctly.

VPNs: Verify routes for tunnel interfaces.

Multi-homed servers: Ensure traffic uses the right gateway.

Example Output
text
default via 192.168.1.1 dev eth0 
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100
3. How to Restart the Network Service
Commands (Distro-Specific)
Distro	Command
systemd	sudo systemctl restart NetworkManager
Debian	sudo systemctl restart networking
RHEL/CentOS	sudo systemctl restart network
Legacy	sudo service networking restart
Use Cases
After config changes: Apply new IP/DNS settings.

Troubleshooting: Resolve transient connectivity issues.

Notes
Avoid restarting over SSH (use tmux/screen to prevent disconnection).

4. Difference Between ping, traceroute, and nslookup
Tool	Purpose	Example
ping	Tests basic connectivity	ping google.com
traceroute	Shows path to destination	traceroute google.com
nslookup	Queries DNS records	nslookup google.com
Use Cases
Ping: Quick latency/connectivity check.

Traceroute: Diagnose routing hops (e.g., where packets drop).

Nslookup: Verify DNS resolution (debugging CDN issues).

5. How to Open/Close a Port Using firewalld
Open a Port
bash
sudo firewall-cmd --zone=public --add-port=80/tcp --permanent
sudo firewall-cmd --reload
Close a Port
bash
sudo firewall-cmd --zone=public --remove-port=80/tcp --permanent
sudo firewall-cmd --reload
Use Cases
Web Servers: Open port 80/443.

Security: Close unused ports (e.g., 22 if using SSH keys).

Verify
bash
sudo firewall-cmd --list-ports
6. How to Test Connectivity to a Remote Server
Methods
bash
telnet <IP> <port>          # Basic TCP test (install with `sudo apt install telnet`)
nc -zv <IP> <port>          # Netcat (quick check)
curl -I http://<IP>:<port>  # HTTP servers
Use Cases
Pre-deployment: Verify a service is reachable.

Firewall testing: Confirm ports are open.

7. Difference Between netstat, ss, and lsof
Tool	Pros	Cons
netstat	Human-readable	Deprecated (use ss)
ss	Faster, modern	Less verbose
lsof	Shows open files/ports	Complex output
Examples
bash
ss -tulnp                   # Replace `netstat -tulnp`
lsof -i :80                 # Find processes using port 80
8. Assign a Static IP to an Interface
Using nmcli (Modern)
bash
sudo nmcli con mod eth0 ipv4.addresses 192.168.1.100/24
sudo nmcli con mod eth0 ipv4.gateway 192.168.1.1
sudo nmcli con mod eth0 ipv4.dns "8.8.8.8"
sudo nmcli con up eth0
Using /etc/network/interfaces (Debian)
bash
# Edit /etc/network/interfaces
auto eth0
iface eth0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    gateway 192.168.1.1
Use Case
Servers: Ensure consistent IPs for services.

9. Configure DNS Servers on Linux
Temporary (Runtime)
bash
sudo nmcli con mod eth0 ipv4.dns "8.8.8.8 8.8.4.4"
sudo systemctl restart NetworkManager
Permanent (Debian/RHEL)
bash
# Edit /etc/resolv.conf (may reset on reboot)
nameserver 8.8.8.8
Use Case
Override ISP DNS: Use Google (8.8.8.8) or Cloudflare (1.1.1.1).

10. Verify a Port is Listening
Commands
bash
ss -tulnp | grep 80         # Modern (recommended)
netstat -tulnp | grep 80    # Legacy
lsof -i :80                 # Alternative
Use Cases
Debugging: Check if Nginx/Apache is bound to port 80.

Security audits: Find unauthorized listeners.

Summary Cheat Sheet
Task	Command
Check IP	ip a
View Routes	ip route show
Restart Network	sudo systemctl restart NetworkManager
Test Port	nc -zv <IP> 80
Static IP	nmcli or /etc/network/interfaces
Check Listening Ports	ss -tulnp
Let me know if you need deeper dives into any topic! 🚀

logs a Logs & System Monitoring
Linux Logs & System Monitoring: Complete Guide
1. Log Files Location & Structure
Linux stores logs in /var/log/. Key files:

Log File	Purpose
/var/log/syslog	General system messages (Debian)
/var/log/messages	General system logs (RHEL)
/var/log/auth.log	Authentication logs (SSH, sudo)
/var/log/kern.log	Kernel messages
/var/log/nginx/*	Nginx access/error logs
/var/log/mysql/*	MySQL logs
View logs in real-time:

bash
tail -f /var/log/syslog  # Follow logs live
2. System & Service Logs (journalctl)
For systemd-managed services:

bash
journalctl -u nginx -f       # Follow Nginx logs
journalctl -p err -b         # Show errors since boot
journalctl --since "1 hour ago"  # Time-based filtering
Key flags:

-u: Filter by service

-f: Follow (like tail -f)

-p: Priority (emerg, alert, err, warning)

-b: Current boot only

3. Process Monitoring (top, htop, ps)
top (Basic Process Viewer)
bash
top -o %CPU  # Sort by CPU usage
Shortcuts:

M: Sort by memory

P: Sort by CPU

k: Kill a process

htop (Enhanced top)
bash
htop         # Colorized, interactive
Features:

Tree view (F5)

Kill processes (F9)

Custom columns

ps (Snapshot of Processes)
bash
ps aux | grep nginx  # Find specific processes
4. Disk & I/O Monitoring
df (Disk Space)
bash
df -h  # Human-readable output
du (Directory Usage)
bash
du -sh /var/log/  # Summary of directory size
iotop (Disk I/O by Process)
bash
sudo iotop -o     # Show active I/O
5. Network Monitoring
ss (Socket Statistics)
bash
ss -tulnp  # List all listening ports
iftop (Bandwidth Usage)
bash
sudo iftop -i eth0  # Live network traffic
nethogs (Bandwidth by Process)
bash
sudo nethogs eth0   # Show per-process traffic
6. System Performance (vmstat, sar)
vmstat (CPU, Memory, I/O)
bash
vmstat 1 5  # Update every 1 sec, 5 times
sar (Historical Stats)
bash
sar -u 1 3   # CPU usage (1 sec intervals, 3 times)
sar -r       # Memory usage
7. Log Rotation (logrotate)
Prevents logs from filling disk space.
Config: /etc/logrotate.conf
Example (rotate Nginx logs):

bash
# /etc/logrotate.d/nginx
/var/log/nginx/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    create 0640 www-data adm
    sharedscripts
    postrotate
        systemctl reload nginx
    endscript
}
8. Centralized Logging (Optional)
For multi-server environments:

rsyslog: Forward logs to a central server.

ELK Stack (Elasticsearch, Logstash, Kibana): Advanced log analysis.

Example (rsyslog):

bash
# On client:
*.* @192.168.1.100:514  # Send logs to server IP 192.168.1.100
9. Alerting & Automation
Fail2Ban (Block Brute Force Attacks)
bash
sudo apt install fail2ban
sudo systemctl enable fail2ban
Config: /etc/fail2ban/jail.local

Custom Alerts (Cron + mailutils)
bash
# Check disk space daily
echo 'df -h | grep -E "9[0-9]%"' | crontab -
10. Summary Cheat Sheet
Task	Command
Follow logs	tail -f /var/log/syslog
Service logs	journalctl -u nginx -f
Process monitor	htop
Disk space	df -h
Network ports	ss -tulnp
Bandwidth	iftop -i eth0
Log rotation	logrotate -vf /etc/logrotate.conf
Best Practices
✅ Regularly check /var/log/ for errors.
✅ Use logrotate to prevent disk fills.
✅ Monitor critical metrics (CPU, RAM, disk, network).
🚨 Set up alerts for anomalies (e.g., 90% disk usage).


